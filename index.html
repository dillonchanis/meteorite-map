<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Meteorite Landings</title>
		
		<link rel="stylesheet" href="main.css" />
		<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.3.0/d3.min.js"></script>
	</head>
	<body>

		<div id="map"></div>
	
		<script>

			//SVG Size
			var width = 960;
			var height = 600;

			//Create our Projection for the Map
			var projection = d3.geoEquirectangular()
				.translate([width/2, height/2])
				.scale(height * 1.5 / Math.PI);

			//Give path our projection
			var path = d3.geoPath().projection(projection);

			//Create SVG
			var svg = d3.select("#map").append("svg")
				.attr("width", width)
				.attr("height", height);

			var g = svg.append("g");

			//Giving SVG zoom ability
			svg.attr("width", width)
				.attr("height", height)
				.style("pointer-events", "all")
		    .call(d3.zoom()
		        .scaleExtent([1, 8])
		        .on("zoom", zoomed));

			function zoomed() {
				g.attr("transform", d3.event.transform);
			}

			//Get GeoJSON data from our world.json file
			d3.json("world.json", function(json) {

				//Draw the Map
				g.selectAll("path")
					.data(json.features)
					.enter()
					.append("path")
					.attr("d", path)
					.attr("fill", "#3A3A3A");

				//Get Meteorite Landing from NASA CSV
				d3.csv("Meteorite_Landings.csv", function(data) {

					//Get meteors with that have a non-zero lat and long
					var meteors = filterMeteors(data);

					var domainMin = d3.min(massArray(meteors));
					var domainMax = d3.max(massArray(meteors));

					//Setup Radius Scale
					//Based on Mass of Meteorite, however this varies greatly
					//Using a scale to limit the size
					//scale = d3.scale.linear.domain([ inputMin, inputMax ]).range([ outputMin, outputMax ]);
					var scale = d3.scalePow().exponent(0.5)
						.domain([0, 1e6])
						.range([2, 15]);

					//Paint the Meteorite Landings on our World Map
					g.selectAll("circle")
						.data(data)
						.enter()
						.append("circle")
						.attr("cx", function(meteors) {
							if(projection([meteors.reclong, meteors.reclat])) {
								return projection([meteors.reclong, meteors.reclat])[0]; 
							}
						})
						.attr("cy", function(meteors) {
							if(projection([meteors.reclong, meteors.reclat])){
								return projection([meteors.reclong, meteors.reclat])[1];
							}
						})
						.attr("transform", function(meteors) {
							return "translate(" + path.centroid(meteors) + ")";
						})
						.attr("r", function(meteors) {
							return scale(meteors["mass (g)"]);
						})
						.append("title")
							.text(function(meteors) {
								return meteors.name;
							})

					//Give all meteorite hits the class 'bubble'
					g.selectAll("circle").attr("class", "bubble");

				});

			});

			//Returns meteors that have GeoLocation data attached to them
			//Takes CSV data and returns an array 
			function filterMeteors(data) {
				return data.map(function(data) {
					if(data.reclong !== 0 && data.reclat !== 0) {
						return data;
					}
				});
			};

			//Create an array from Meteor CSV data of just Mass
			function massArray(data) {
				return data.map(function(data) {
					if(data["mass (g)"]) {
						return data["mass (g)"];
					}
				});
			};

		</script>
	
	</body>
</html>